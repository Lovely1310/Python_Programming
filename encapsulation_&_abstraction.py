# -*- coding: utf-8 -*-
"""Encapsulation_&_Abstraction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14p5eXR1WSBEcyZkgBVMJluARLaL8q5Rm
"""

# class & instance Attributes
class Car:
  car_showroom = "Maruti"
  brand = "Anonymous"

  def __init__(self, model , brand):
    self.brand = brand
    self.model = model
    print(" Added new car")

c1 = Car("swift", "Baleno")
print(c1.brand)

#Encapsulation - Wrapping up data & functions into a single unit(object). Public - syntax :- variable(accessed anywhere) , protected syntax - _variable(should not be accessed directly), private syntax - __variable (Can't be accessed directly)
class student:
  def __init__(self, name, marks):
    self.name = name           #public variable
    self.__marks = marks       #private Variable
  def set_marks(self,marks):
    if marks <0:
      print("invalid marks")
    else:
      self.__marks = marks
  def get_marks(self):
    return self.__marks
s1 = student("monika", 90)
print(s1.name)
print(s1.get_marks())
s1.set_marks(99.9)        # updating marks with the set_marks() to change
print(s1.get_marks())      # access is controlled , data is hidden , encapsulation means hidding data & accessing it through methods

# Another Example of Encapsulation
class Employee:
  def __init__(self, name, salary):
    self.name = name
    self.__salary = salary
  def set_salary(self, salary):
    if salary > 0 :
      self.__salary = salary
    else:
      print("Salary cannot be negative")
  def get_salary(self):
   return self.__salary
emp1 = Employee("john", 50000)
print(emp1.get_salary())
emp1.set_salary(60000)
print(emp1.get_salary())
print(emp1.name)

# Abstraction - Hiding Implementation Details of the class & showing only essential features to the user
class Car:
  def __init__(self):
    self.acc = False
    self.brk = False
    self.clutch = False
  def start(self):
    self.acc = True
    print("car started")
c1 = Car()
c1.start()

# # Abstraction Uses abstract methods , it focuses on simplicity
# Abstraction is the process of hiding internal implementation details and showing only essential features. In Python, it is implemented using abstract classes and abstract methods from the abc module.
from abc import ABC, abstractmethod

#abstract Class
class Animal(ABC):
  @abstractmethod
  def sound(self):
    pass
class Dog(Animal):
  def sound(self):
    print("bark")

class cat(Animal):
   def sound(self):
    print("meow")

# a1 = Animal()  #it gives error , cannot be instantiated Because abstract class cannot be instantiated.
# a1.sound

d1 = Dog()
d1.sound()

c1 = cat()
c1.sound()

# What Is Happening?

# Animal is abstract class.

# It forces child classes to implement sound().

# If a class does not implement sound(), it gives error.

from abc import ABC, abstractmethod
class payment(ABC):
  @abstractmethod
  def payment_method(self):
    pass
class credit_card(payment):
  def payment_method(self):
    print("credit card")

class upi(payment):
  def payment_method(self):
    print("upi")

c1 = credit_card()
c1.payment_method()

u1 = upi()
u1.payment_method()